version 1;

package argon.vm;


enum VMType {
    version 1 {
        i8: unit;
        i16: unit;
        i32: unit;
        i64: unit;
        f32: unit;
        f64: unit;
        gcref: unit;
        gcptr: unit;
        tuple: list<VMType>;
    }
}

struct Name {
    version 1 {
        parts: list<string>;
    }
}

struct LocalId {
    version 1 {
        num: int;
    }
}

struct ConstantPoolIndex {
    version 1 {
        num: int;
    }
}

struct LabelId {
    version 1 {
        num: int;
    }
}

struct LoadConstant<T> {
    version 1 {
        out: LocalId;
        value: T;
    }
}

struct UnaryOp {
    version 1 {
        out: LocalId;
        in: LocalId;
    }
}

struct BinaryOp {
    version 1 {
        out: LocalId;
        a: LocalId;
        b: LocalId;
    }
}

struct FunctionCall {
    version 1 {
        id: ConstantPoolIndex;
        args: list<LocalId>;
        result: LocalId;
    }
}

struct DerefLoad {
    version 1 {
        out: LocalId;
        ptr: LocalId;
        elementType: VMType;
    }
}

struct DerefStore {
    version 1 {
        ptr: LocalId;
        src: LocalId;
        elementType: VMType;
    }
}

struct LoadFieldReference {
    version 1 {
        out: LocalId;
        instance: LocalId;
        field: ConstantPoolIndex;
    }
}

struct CreateObject {
    version 1 {
        out: LocalId;
        classId: ConstantPoolIndex;
    }
}

enum Instruction {
    version 1 {
        constI: LoadConstant<int>;
        constInt: LoadConstant<int>;
        constString: LoadConstant<string>;
        constNull: LocalId;


        convertSignExt: UnaryOp;
        convertZeroPad: UnaryOp;
        convertWrap: UnaryOp;

        add: BinaryOp;
        sub: BinaryOp;
        mul: BinaryOp;
        div: BinaryOp;
        divU: BinaryOp;
        rem: BinaryOp;
        remU: BinaryOp;
        negate: UnaryOp;
        shiftLeft: BinaryOp;
        shiftRightS: BinaryOp;
        shiftRightU: BinaryOp;
        bitAnd: BinaryOp;
        bitOr: BinaryOp;
        bitXOr: BinaryOp;
        bitNot: UnaryOp;

        equalTo: BinaryOp;
        notEqualTo: BinaryOp;
        lessThan: BinaryOp;
        lessThanU: BinaryOp;
        lessThanEq: BinaryOp;
        lessThanEqU: BinaryOp;
        greaterThan: BinaryOp;
        greaterThanU: BinaryOp;
        greaterThanEq: BinaryOp;
        greaterThanEqU: BinaryOp;
        equalToZero: UnaryOp;
        notEqualToZero: UnaryOp;

        call: FunctionCall;
        callDirect: FunctionCall;

        derefLoad: DerefLoad;
        derefStore: DerefStore;
        loadFieldReference: LoadFieldReference;

        createObject: CreateObject;


    }
}

struct JITailCall {
    version 1 {
        id: ConstantPoolIndex;
        args: list<LocalId>;
    }
}

struct JIReturn {
    version 1 {
        value: LocalId;
    }
}

struct JIJump {
    version 1 {
        label: LabelId;
    }
}

struct JIJumpZero {
    version 1 {
        value: LocalId;
        zTarget: LabelId;
        nzTarget: LabelId;
    }
}

struct JIThrow {
    version 1 {
        exception: LocalId;
    }
}


enum JumpInstruction {
    version 1 {
        tailCall: JITailCall;
        tailCallDirect: JITailCall;
        return: JIReturn;
        jump: JIJump;
        jumpZero: JIJumpZero;
        throw: JIThrow;
    }
}

struct KeyValuePair<K, V> {
    version 1 {
        key: K;
        value: V;
    }
}

struct ControlFlowGraph {
    version 1 {
        blocks: list<BasicBlock>;
    }
}

struct BasicBlock {
    version 1 {
        instructions: list<Instruction>;
        jump: JumpInstruction;
    }
}

struct FunctionBody {
    version 1 {
        localVariables: list<VMType>;
        graph: ControlFlowGraph;
    }
}

struct Import {
    version 1 {
        tubeName: Name;
        exportedName: Name;
    }
}

struct FunctionDefinition {
    version 1 {
        parameterTypes: list<VMType>;
        returnType: VMType;
        body: option<FunctionBody>;
    }
}

struct FieldDefinition {
    version 1 {
        type: VMType;
    }
}

struct ClassDefinition {
    version 1 {
        abstract: bool;
        final: bool;
        fields: list<ConstantPoolIndex>;
        functions: list<ConstantPoolIndex>;
        overrides: list<KeyValuePair<ConstantPoolIndex, ConstantPoolIndex>>;
    }
}

enum ConstantPoolEntry {
    version 1 {
        import: Import;
        function: FunctionDefinition;
        method: FunctionDefinition;
        field: FieldDefinition;
        class: ClassDefinition;
    }
}

struct ConstantPool {
    version 1 {
        entries: list<ConstantPoolEntry>;
    }
}

struct Tube {
    version 1 {
        tubeName: Name;
        constantPool: ConstantPool;
        exports: list<KeyValuePair<Name, ConstantPoolIndex>>;
    }
}

